# 00 — Preface: How to Read and Use This Guide

## Note
- This repository is not traditional documentation.
- File numbering in this repository is intentional and semantic.
- File order defines authority and reading order.
- **Do not renumber or reorder documents.**


It is a **playbook** — a collection of explicit rules, constraints, and patterns that define how Oqtane modules should be built when correctness, safety, and longevity matter.

This preface explains **how to interpret the content**, **how authority is expressed**, and **how this guide is intended to be used** by both humans and AI tools.

---

## What This Guide Is

This guide is:

- A framework-aware reference for Oqtane module development
- A codification of **implicit architectural rules**
- A set of **enforceable constraints**, not stylistic advice
- A tool to make AI-assisted development safe and predictable
- A living document grounded in real-world experience

It exists to remove ambiguity.

---

## What This Guide Is Not

This guide is **not**:

- A beginner tutorial
- A walkthrough of Oqtane features
- A replacement for official Oqtane documentation
- A style guide or personal preference list
- A collection of “best practices” without consequences

If you are looking for introductory material, consult the official Oqtane documentation first.

---

## How This Guide Is Structured

This repository uses **intentional numbering** to convey authority and scope.

### Numbering Is Semantic

File numbers are **not cosmetic**.

They define how strictly the content must be followed.

---

### `00–09` — Orientation & Governance

These documents explain:

- Why this guide exists
- How it should be interpreted
- What problems it solves
- What it explicitly does *not* try to solve

They establish context and authority.

---

### `10–25` — Oqtane Framework Invariants (Non-Negotiable)

These documents define **how Oqtane actually works**.

They describe:
- Lifecycle ownership
- Multi-tenant constraints
- Required base classes
- Authorization and execution boundaries
- Migration and scheduling rules

Violating rules in this range will result in:
- Subtle bugs
- Security issues
- Upgrade failures
- Unpredictable behavior

These are **hard constraints**.

If code violates these rules, it should be rejected.

---

### `26–99` — Application, Team, and AI Practices

These documents describe:
- How to apply the framework rules in real projects
- How to adopt the playbook incrementally
- How to govern AI-assisted development
- How teams can structure repositories and templates

These are **constrained practices**, not framework law.

They may evolve and be adapted.

---

### `100+` — Synthesis and Closure

These documents summarize intent, reinforce principles, and intentionally mark the end of the guide.

---

## Authority Model

Not all guidance in this repository has equal weight.

Authority increases as follows:

1. Oqtane framework behavior
2. Oqtane source code
3. Structural stubs generated by official tooling
4. Rules in the `10–25` range
5. Practices in the `26–99` range

Prose never overrides behavior.

Examples never override the framework.

---

## How to Use This Guide in Practice

This guide is most effective when used as:

- A **design review reference**
- A **Copilot governance source**
- A **team alignment document**
- A **shared vocabulary for code reviews**

You do not need to adopt everything at once.

The recommended approach is:
- Freeze structure
- Enforce rules on new code
- Align existing code only when touched

---

## AI Tooling (Important)

AI tools optimize for plausibility, not correctness.

When using this guide with tools such as GitHub Copilot:

- Treat rules as **rejectable constraints**
- Anchor AI to authoritative examples
- Prevent structure from being invented
- Prefer copying known-good patterns over generating new ones

This guide exists to remove uncertainty so AI can be useful.

---

## Contributions and Evolution

This repository is intentionally open to improvement.

Valid contributions include:
- Clarifications
- Corrections
- Edge cases
- Additional invariant rules
- Real-world failure examples

The goal is shared understanding, not personal ownership.

---

## Final Note

Frameworks do not fail.
Developers do not fail.
Tools do not fail.

**Unspoken rules fail.**

Everything that follows exists to make those rules explicit.
