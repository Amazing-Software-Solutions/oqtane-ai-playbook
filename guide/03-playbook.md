# 03 — The Oqtane Playbook Pattern

The insight from the previous chapter leads to a practical question:

> If AI needs governance, what does that governance look like in real projects?

The answer is not a single prompt, tool, or configuration setting.

It is a **pattern**.

This chapter introduces the **Oqtane Playbook Pattern** — a lightweight but powerful way to encode architectural reality so both humans and AI can work safely within it.

---

## What Is the Oqtane Playbook?

An Oqtane Playbook is a **central, authoritative collection of rules and structures** that define how Oqtane modules are built.

It is:
- Explicit
- Versioned
- Machine-readable
- Framework-aligned

It does not replace documentation.
It does not enforce style preferences.
It does not attempt to teach Oqtane from scratch.

Instead, it answers one question:

> *What must always be true in a correct Oqtane module?*

---

## Why a “Playbook”?

The term *playbook* is intentional.

A playbook:
- Defines allowed moves
- Defines forbidden moves
- Encodes strategy, not tactics
- Is reusable across situations

This mirrors how experienced Oqtane developers actually work:
- Certain decisions are already settled
- Certain patterns are non-negotiable
- Certain mistakes are well-known and costly

The playbook makes those realities explicit.

---

## Core Principles of the Playbook Pattern

### 1. Rules Are First-Class Artifacts

Rules are written down as:
- Markdown files
- Stored in version control
- Reviewed like code
- Referenced by tooling

They are not tribal knowledge.
They are not comments.
They are not “best practice” suggestions.

They are enforceable constraints.

---

### 2. Rejection Is Preferable to Guessing

A key principle of the playbook is this:

> It is better for AI to refuse than to be creative.

Rules are written with language such as:
- **MUST**
- **MUST NOT**
- **NEVER**
- **Reject if violated**

This intentionally narrows the solution space.

---

### 3. Structure Has Authority Over Explanation

The playbook favors:
- Real module layouts
- Minimal stubs generated by official tools
- Canonical folder and file structures

Over:
- Abstract descriptions
- Conceptual diagrams alone
- Verbal explanations

AI copies structure more reliably than it reasons about it.

---

### 4. Centralization Prevents Drift

The playbook lives in **one place**.

Projects do not copy it.
They reference it.

This ensures:
- Consistency across solutions
- Intentional updates
- No silent divergence
- Clear ownership

---

## What the Playbook Contains

A typical Oqtane Playbook contains three categories of content.

---

### 1️⃣ Rule Sets (Governance)

Each rule set focuses on a specific architectural area, for example:

- Services
- Authorization
- Database Migrations
- Scheduled Jobs

Each rule set:
- Explains the mental model
- Defines hard rules
- Includes rejection criteria
- Avoids implementation noise

Rules answer *what must be true*, not *how to code everything*.

---

### 2️⃣ Structural Stubs (Authority)

Structural stubs are:
- Minimal
- Real
- Generated by the Oqtane Module Manager
- Free of business logic

They exist to answer questions like:
- Where does this code live?
- What base class should this inherit from?
- How are projects laid out?
- What does “correct” look like structurally?

They are not examples — they are **reference reality**.

---

### 3️⃣ Minimal Templates (Execution)

Templates provide:
- Safe starting points
- Correct inheritance
- Correct DI patterns
- No optional features

Templates are intentionally boring.

They exist to reduce variance, not to inspire creativity.

---

## How the Playbook Is Used

The playbook is not something developers read once.

It is used continuously:

- By AI tools when generating code
- By developers when reviewing changes
- By teams when onboarding
- By maintainers when evaluating modules

In practice:
- New code must conform
- Existing code is aligned opportunistically
- Violations become obvious and discussable

---

## What the Playbook Is Not

To avoid misunderstanding, it is important to be explicit.

The Oqtane Playbook is **not**:

- A replacement for Oqtane documentation
- A rigid framework on top of Oqtane
- A set of personal preferences
- A style guide
- A mandate for any specific AI tool

It is a governance layer, not a rewrite.

---

## Why This Works for Oqtane

Oqtane is particularly well-suited to this pattern because:

- It has strong architectural boundaries
- It has clear ownership of responsibilities
- It is sensitive to misuse
- It supports extensibility through modules

The playbook makes those boundaries visible and enforceable.

---

## The Human Benefit

While the playbook is designed to guide AI, it also helps humans:

- Senior developers spend less time correcting fundamentals
- Junior developers get safer guardrails
- Code reviews focus on intent, not structure
- Onboarding becomes faster and less error-prone

The same rules that constrain AI also improve human consistency.

---

## The AI Benefit

For AI tools, the playbook provides:

- Persistent context
- Explicit constraints
- Canonical structures
- Clear rejection signals

This turns AI from a guessing engine into a predictable collaborator.

---

## From Pattern to Practice

The playbook pattern is only useful if it is applied consistently.

The next chapters will show:
- How to encode specific Oqtane rules
- How to structure rule files
- How to introduce the playbook into existing projects
- How to evolve it safely over time

The next chapter focuses on the first concrete rule set:

> **Services: contracts, boundaries, and responsibility separation**
